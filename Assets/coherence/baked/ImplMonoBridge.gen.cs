// Copyright (c) coherence ApS.
// See the license file in the project root for more information.

// <auto-generated>
// Generated file. DO NOT EDIT!
// </auto-generated>
namespace Coherence.Toolkit
{
	using UnityEngine;
	using Unity.Collections;
	using System;
	using Coherence.Entity;
	using Coherence.Generated;
	using Coherence.ProtocolDef;
	using ConnectionType = Coherence.Connection.ConnectionType;

	public class CoherenceMonoBridgeImpl
	{
		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		static void OnRuntimeMethodLoad()
		{
			CoherenceMonoBridge.GenericPrefabReferenceTypeID = GenericPrefabReferenceTypeID;
			CoherenceMonoBridge.GetSpawnInfo = GetSpawnInfo;
			CoherenceMonoBridge.GetRootDefinition = GetRootDefinition;
		}

		private static uint GenericPrefabReferenceTypeID()
		{
			return Definition.InternalGenericPrefabReference;
		}

		static (bool, CoherenceMonoBridge.SpawnInfo) GetSpawnInfo(IClient client, EntityUpdate entityUpdate)
		{
			var info = new CoherenceMonoBridge.SpawnInfo();
			var gotPosition = false;
			var gotPrefabReference = false;

			foreach (var comp in entityUpdate.Components.Updates.Store)
			{
				switch(comp.Value.Data)
				{
					case WorldPosition pos:
						info.position = pos.value;
						gotPosition = true;
						break;
					case WorldOrientation rot:
						info.rotation = rot.value;
						break;
					case GenericPrefabReference prefabRef:
						info.prefabName = prefabRef.prefab;
						gotPrefabReference = true;
						break;
					case ConnectedEntity connectedEntity:
						info.connectedEntity = connectedEntity.value;
						break;
					case Connection con:
						info.clientId = con.id;
						info.connectionType = (ConnectionType)con.type;
						break;
					case UniqueID uid:
					    info.uniqueId = uid.uuid;
					    break;
				}
			}

			var shouldSpawn = (gotPosition && gotPrefabReference) || info.clientId.HasValue;

			return (shouldSpawn, info);
		}

		private static IDefinition GetRootDefinition()
		{
			return new Definition();
		}
	}
}
